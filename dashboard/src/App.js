import React from 'react';
import AqlEditor from './aql-editor';
import {Button, Table, TabContent, TabPane, Nav, NavItem, NavLink} from 'reactstrap';
import InformationTooltip from './information-tooltip';
import {FontAwesomeIcon} from '@fortawesome/react-fontawesome'
import {faListAlt, faFileCode, faChartBar} from '@fortawesome/free-regular-svg-icons';
import TimeSeriesChart from './time-series';
import { TimeSeries, Index } from "pondjs";
import { pure } from 'recompose';
import * as moment from 'moment';
import _ from 'lodash';
import 'bootstrap/dist/css/bootstrap.min.css';
import './App.css';
import {styler} from "react-timeseries-charts";

const getFormatterFor = function (heading) {
  if (heading === 'created_at' || heading === 'timeseries') {
    return value => moment(value).fromNow();
  }

  // Identity
  return x => x;
};

const ListView = pure(({ results }) => {
  if (results.rows.length === 0) return <div>No results</div>;

  // The server should expand wildcard to select only the fields we care about, let's cheat for now.
  const headings = Object.keys(results.rows[0]).filter(heading => !(heading === 'id' || heading === 'deleted_at'));

  return (
    <div>
      <Table>
        <thead>
        <tr>
          <th>#</th>
          {headings.map(function (value) {
            return <th key={value}>{value}</th>
          })}
        </tr>
        </thead>

        <tbody>
        {results.rows.map(function (row, index) {
          return (
            <tr key={index}>
              <th scope="row">{index + 1}</th>
              {headings.map(function (heading) {
                const formatter = getFormatterFor(heading);
                const value = formatter(row[heading]);

                return <td key={heading}>{value}</td>
              })}
            </tr>
          );
        })}
        </tbody>
      </Table>
    </div>
  );
});


const getAggregationKeyFor = function (results) {
  if (results.rowCount === 0) {
   return undefined;
  }

  // TODO: Guess the key blindly for now. The best way to handle this might be the server returning
  // the data directly in a usable format by our charts, rather than the client guessing what to aggregate on
  const possibleAggregations = ['count', 'sum', 'avg', 'min', 'max', 'coalesce'];
  const key = possibleAggregations.find(function (key) {
    if (key in results.rows[0]) {
      return key;
    }
  });

  return key;
};

const ChartView = pure(({ results }) => {
  if (results.rows.length === 0) {
    return <div>There is no data to plot</div>
  }

  const key = getAggregationKeyFor(results);
  if (!key) return <div>Only Aggregate functions can be plotted</div>;

  // TODO: This is an indication that perhaps we always want to chart as a timeseries, or alternatively a barChart
  const defaultTimeForNonTimeSeriesCharts = moment.utc().toISOString();

  let columnsSet = {};
  const timeSeriesToValues = results.rows.reduce(function (acc, row) {
    const timeseries = row.timeseries || defaultTimeForNonTimeSeriesCharts;
    acc[timeseries] = acc[timeseries] || {};
    const availableColumns = _.without(Object.keys(row), 'timeseries', 'time');
    let facetName;

    if (availableColumns.length === 1) {
      facetName = availableColumns[0];
    } else {
      const columnName = _.without(availableColumns, key)[0];
      facetName = row[columnName];
    }

    if (facetName === null) {
      return acc;
    }

    acc[timeseries][facetName] = row[key];
    columnsSet[facetName] = true;

    return acc;
  }, {});

  const columns = Object.keys(columnsSet);
  const points = Object.keys(timeSeriesToValues).map(function (timeSeriesKey) {
    const asNumber = value => Number((value && value.match(/^\$?(.*)/)[1]) || 0);
    const values = columns.map(column => asNumber(timeSeriesToValues[timeSeriesKey][column]) || 0);

    return [moment.utc(timeSeriesKey).valueOf()].concat(values)
  });

  const data = {
    name: `${key} of results`,
    columns: ["time"].concat(columns),
    points: _.reverse(points)
  };

  const series = new TimeSeries(data);

  const style = styler(columns.map(function (column) {
    // The color will be generated by default using color brewer
    return {
      key: column,
      width: 2,
    };
  }));

  // return <pre>{JSON.stringify(points, null, 4)}</pre>;

  return (
    <TimeSeriesChart
      yLabel={key}
      series={series}
      style={style} />
  );
});

const DataView = pure(({ results }) => {
  return (
    <div style={{ backgroundColor: '#F6F6F6', border: '1px solid #dee2e6', padding: '1rem' }}>
      <pre>
        {JSON.stringify(results, null, 4)}
      </pre>
    </div>
  );
});

const resultsView = {
  listView: 'list-view',
  dataView: 'data-view',
  chartView: 'chart-view',
};

const ToggleView = ({ onClick, value, isActive, icon }) => {
  return (
    <NavItem>
      <NavLink
        className={isActive ? 'active' : ''}
        onClick={() => {
          onClick(value);
        }}
      >
        <FontAwesomeIcon icon={icon} color={isActive ? '#333' : '#AAA'}/>
      </NavLink>
    </NavItem>
  )
};

const Results = ({ results, view }) => {
  if (!results.rows) return null;

  return (
    <div style={{ background: '#FFFFFF', padding: '1rem' }}>
      <TabContent activeTab={view}>
        <TabPane tabId={resultsView.listView}>
          <ListView results={results}/>
        </TabPane>
        <TabPane tabId={resultsView.dataView}>
          <DataView results={results}/>
        </TabPane>
        <TabPane tabId={resultsView.chartView}>
          <ChartView results={results}/>
        </TabPane>
      </TabContent>
    </div>
  )
};

const ShowQuery = pure(({ results }) => {
  const hasExecuted = (results && results.command);
  if (!hasExecuted) return null;
  return null;
  return (
    <div className="alert alert-primary" role="alert">
      Server executed query:
      <pre style={{ margin: '0' }}>
        {results.command}
      </pre>
    </div>
  );
});

class App extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      value: window.sessionStorage.value || "select * from products_view",
      results: undefined
    };
  }

  componentDidMount() {
    this.onFetchResults();
  }

  onChange = (newValue) => {
    window.sessionStorage.value = newValue;
    this.setState({ value: newValue });
  };

  onFetchResults = () => {
    this.setState({ results: {} });

    fetch('/results', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ query: this.state.value }),
    })
      .then(res => res.json())
      .then((results) => {
        const isAggregation = typeof getAggregationKeyFor(results) === "string";

        this.setState({
          results: results,
          view: isAggregation ? resultsView.chartView : resultsView.listView
        })
      });
  };

  onToggleView = (view) => {
    this.setState({ view: view });
  };

  render() {
    const { view, results } = this.state;

    return (
      <div style={{ padding: '2rem' }}>
        <div style={{
          display: 'flex',
          backgroundColor: '#1e1e1e',
          padding: '0.8rem',
          borderRadius: '.25rem',
          marginBottom: '1rem'
        }}>
          <AqlEditor
            value={this.state.value}
            onChange={this.onChange}
            onFetchResults={this.onFetchResults}
          />
          <div
            style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0 0 0 0.5rem' }}>
            <div style={{ display: 'flex', alignItems: 'center' }}>
              <Button onClick={this.onFetchResults}>
                Run
              </Button>
              <div style={{ margin: '0 0.5rem' }}>

              </div>
              <InformationTooltip>
                <div>
                  <div><a href='#help'>Full SQL explanation</a></div>
                  <div>Run with Ctrl/Cmd + Enter</div>
                </div>
              </InformationTooltip>
            </div>
          </div>
        </div>

        {(results && results.errors && results.errors.length > 0) && (
          <div className="alert alert-danger" role="alert">
            <pre>
              {JSON.stringify(results.errors, null, 4)}
            </pre>
          </div>
        )}

        <ShowQuery results={results}/>

        {results && results.rows && (
          <Nav tabs>
            <ToggleView
              isActive={view === resultsView.listView}
              icon={faListAlt}
              value={resultsView.listView}
              onClick={this.onToggleView}
            />
            <ToggleView
              isActive={view === resultsView.chartView}
              icon={faChartBar}
              value={resultsView.chartView}
              onClick={this.onToggleView}
            />
            <ToggleView
              isActive={view === resultsView.dataView}
              icon={faFileCode}
              value={resultsView.dataView}
              onClick={this.onToggleView}
            />
          </Nav>
        )}

        {results && (
          <div style={{
            borderLeft: '1px solid #dee2e6',
            borderRight: '1px solid #dee2e6',
            borderBottom: '1px solid #dee2e6',
          }}>
            <Results
              results={results}
              view={view}
            />
          </div>
        )}
      </div>
    )
  }
}

export default App;
